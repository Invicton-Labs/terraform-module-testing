name: 'Terraform Module Testing Matrix'
description: 'Generates a Terraform module testing matrix for use with GitHub Actions.'

inputs:
  minimum_tf_version:
    description: "The minimum version of Terraform to test with."
    required: true

  excluded_tf_versions:
    description: "A comma-separated list of Terraform versions to exclude for testing."
    required: false
    default: ""

outputs:
  strategy: 
    description: "The JSON-encoded strategy to use for the testing jobs."
    value: ${{ steps.matrix.outputs.matrix }}

runs:
  using: 'composite'

  steps:

    # Get the list of Linux images that we want to test on
    - name: Get Images
      id: images
      shell: bash
      run: echo ::set-output name=images::'["alpine:latest", "redhat/ubi9:latest", "fedora:latest", "centos:latest", "ubuntu:latest", "amazonlinux:1", "amazonlinux:2"]'

    # Get the list of Windows operating systems to test on
    - name: Get Windows Operating Systems
      id: windows
      shell: bash
      run: echo ::set-output name=names::'["windows-2022", "windows-2019"]'

    # Get the list of MacOS operating systems to test on
    - name: Get MacOS Operating Systems
      id: macos
      shell: bash
      run: echo ::set-output name=names::'["mac-12", "mac-11", "mac-10.15"]'

    # Get the full list of Terraform versions.
    # For each major/minor version, only get the first release (no subsequent patch versions)
    - name: Get Terraform Versions
      id: terraform
      shell: bash
      run: |
        set -eu -o pipefail
        # Strip whitespace from the minimum version input
        minimum_version=$(echo "${{ inputs.minimum_tf_version }}" | sed 's/[[:blank:]]//g')
        # Remove any whitespace from our excluded version string and split it on commas
        IFS=',' read -r -a excluded_versions <<< $(echo "${{ inputs.excluded_tf_versions }}" | sed 's/[[:blank:]]//g')
        minimum_major=$(echo $minimum_version | cut -d. -f1)
        minimum_minor=$(echo $minimum_version | cut -d. -f2)
        minimum_patch=$(echo $minimum_version | cut -d. -f3)

        versions_html=$(curl -s https://releases.hashicorp.com/terraform/ 2>&1)
        version_lines=$(echo "$versions_html" | grep -oE "terraform/[0-9]+\.[0-9]+\.[0-9]+/")

        contains_element () {
          local e match="$1"
          shift
          for e; do [[ "$e" == "$match" ]] && return 0; done
          return 1
        }

        selected_versions=()
        declare -A found_major_minor

        while read -r version ; do
            major=$(echo $version | cut -d. -f1)
            minor=$(echo $version | cut -d. -f2)
            patch=$(echo $version | cut -d. -f3)

            # If the major/minor combination doesn't exist in the associative array, consider this version
            if ! [ ${found_major_minor["$major.$minor"]+_} ]; then
                # Ensure it's at least as recent as our lowest version
                if [ $major -gt $minimum_major ] || ( [ $major -eq $minimum_major ] && [ $minor -gt $minimum_minor ] ) || ( [ $major -eq $minimum_major ] && [ $minor -eq $minimum_minor ] && [ $patch -ge $minimum_patch ] ); then
                    # Ensure the version we're considering isn't explicitly excluded
                    if ! contains_element $version "${excluded_versions[@]}"; then
                        found_major_minor["$major.$minor"]=true
                        selected_versions+=("$version")
                    fi
                fi
            fi
        done <<<$(echo "$version_lines" | grep -oE "[0-9]+\.[0-9]+\.[0-9]+" | sort --version-sort --field-separator=.)

        # Sort the version numbers, descending
        IFS=$'\n' selected_versions=($(sort -r --version-sort --field-separator=. <<<"${selected_versions[*]}"))
        unset IFS

        join_by () { local IFS="$1"; shift; echo "$*"; }

        echo ::set-output name=versions::$(jq -n --arg inarr $(join_by , ${selected_versions[@]}) '$inarr | split(",")')

    # Generate excluded container configurations.
    # amazonlinux doesn't support anything below TF v0.13.x
    - name: Generate Matrix
      id: matrix
      shell: bash
      run: |
        set -eu -o pipefail

        windows_versions='${{ steps.windows.outputs.names }}'
        macos_versions='${{ steps.macos.outputs.names }}'
        images='${{ steps.images.outputs.images }}'
        tf_versions='${{ steps.terraform.outputs.versions }}'

        matrix=()

        # Start with the Linux containers
        for image in $(echo "${images}" | jq -r '.[]'); do
          for version in $(echo "${tf_versions}" | jq -r '.[]'); do
            major=$(echo $version | cut -d. -f1)
            minor=$(echo $version | cut -d. -f2)
            # Exclude Amazon Linux 1/2 with any version less than 14
            if ! ( [ $major -eq 0 ] && [ $minor -lt 14 ] && ( [ "$image" = "amazonlinux:1" ] || [ "$image" = "amazonlinux:2" ] )) then
              matrix+=("{\"container\": {\"image\": \"$image\"}, \"terraform_version\": \"$version\", \"runs-on\": \"ubuntu-latest\"}")
            fi
          done
        done

        # Add the Linux shell configurations
        for version in $(echo "${tf_versions}" | jq -r '.[]'); do
          matrix+=("{\"terraform_version\": \"$version\", \"runs-on\": \"ubuntu-latest\", \"shells\": \"true\", \"container\": \"\"}")
        done

        # Add the non-Linux configurations
        for os in $(echo "${windows_versions}" | jq -r '.[]'); do
          for version in $(echo "${tf_versions}" | jq -r '.[]'); do
            matrix+=("{\"runs-on\": \"$os\", \"terraform_version\": \"$version\", \"container\": \"\"}")
          done
        done
        for os in $(echo "${macos_versions}" | jq -r '.[]'); do
          for version in $(echo "${tf_versions}" | jq -r '.[]'); do
            matrix+=("{\"runs-on\": \"$os\", \"terraform_version\": \"$version\", \"container\": \"\"}")
          done
        done

        _matrix=$(echo "${matrix[@]}" | jq -rs '.' )
        echo ::set-output name=matrix::$(jq -n --argjson matrix "$_matrix" '{"fail-fast": false, "matrix": {"include": $matrix}}')
